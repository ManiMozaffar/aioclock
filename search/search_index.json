{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AioClock","text":""},{"location":"#the-principle","title":"The Principle","text":"<p>Scheduling is annoying, stateful and hard to scale. But not anymore! AioClock is here as an asyncio-based scheduling framework designed for execution of periodic task with integrated support for dependency injection, enabling efficient and flexiable task management.</p> <p>Aioclock offers:</p> <ul> <li>Async: 100% Async, very light, fast and resource friendly</li> <li>Scheduling: Keep scheduling tasks for you</li> <li>Group: Group your task, for better code maintainability</li> <li>Trigger: Already defined and easily extendable triggers, to trigger your scheduler to be started</li> <li>Easy syntax: Library's syntax is very easy and enjoyable, no confusing hierarchy</li> <li>Pydantic v2 validation: Validate all your trigger on startup using pydantic 2. Fastest to fail possible!</li> <li>Soon: Running the task dispatcher (scheduler) on different process by default, so CPU intensive stuff on task won't delay the scheduling</li> <li>Soon: Backend support, to allow horizontal scalling, by synchronizing, maybe using Redis</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To Install aioclock, simply do</p> <pre><code>pip install aioclock\n</code></pre> <p>AioClock is very user friendly and easy to use, it's type stated library to use easily. AioClock always have a trigger, that trigger the events.</p> <pre><code>import asyncio\n\nfrom aioclock import AioClock, At, Depends, Every, Forever, Once, OnShutDown, OnStartUp\nfrom aioclock.group import Group\n\n# groups.py\ngroup = Group()\n\n\ndef more_useless_than_me():\n    return \"I'm a dependency. I'm more useless than a screen door on a submarine.\"\n\n\n@group.task(trigger=Every(seconds=10))\nasync def every():\n    print(\"Every 10 seconds, I make a quantum leap. Where will I land next?\")\n\n\n@group.task(trigger=At(tz=\"UTC\", hour=0, minute=0, second=0))\nasync def at():\n    print(\n        \"When the clock strikes midnight... I turn into a pumpkin. Just kidding, I run this task!\"\n    )\n\n\n@group.task(trigger=Forever())\nasync def forever(val: str = Depends(more_useless_than_me)):\n    await asyncio.sleep(2)\n    print(\"Heartbeat detected. Still not a zombie. Will check again in a bit.\")\n    assert val == \"I'm a dependency. I'm more useless than a screen door on a submarine.\"\n\n\n@group.task(trigger=Once())\nasync def once():\n    print(\"Just once, I get to say something. Here it goes... I love lamp.\")\n\n\n# app.py\napp = AioClock()\napp.include_group(group)\n\n\n@app.task(trigger=OnStartUp())\nasync def startup():\n    print(\n        \"Welcome to the Async Chronicles! Did you know a group of unicorns is called a blessing? Well, now you do!\"\n    )\n\n\n@app.task(trigger=OnShutDown())\nasync def shutdown():\n    print(\"Going offline. Remember, if your code is running, you better go catch it!\")\n\n\n# main.py\nif __name__ == \"__main__\":\n    asyncio.run(app.serve())\n</code></pre>"},{"location":"alternative/","title":"AioClock VS Alternatives","text":"<p>There are other alternatives for scheduling as well. This section contains comparisons between AioClock and other scheduling tools. Credit to Rocketry library, as the comparison is inspired by that.</p> <p>Features unique for AioClock:</p> <ul> <li>Simplicity: With being super-simple, it's very easy to extend the library as you wish, which is not the usual case with other solutions!</li> <li>Trigger-based scheduling: Trigger based scheduling allows flexibility, making it very easy to run a task at a certain time in future.</li> <li>Dependency Injection System: Just like FastAPI, AioClock has a very similiar injection system which you can use to decouple your dependency.</li> <li>Declarative Syntax: AioClock promotes declarative syntax which makes the library easy to use.</li> </ul>"},{"location":"alternative/#aioclock-vs-rocketry","title":"AioClock vs Rocketry","text":"<p>Rocketry is a modern statement-based scheduling framework for Python. It is simple, clean and extensive. It is suitable for small and big projects.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You need a truly light weight solution.</li> <li>You are using Pydantic v2.</li> <li>Type safety is important to you. All triggers are type safe, but some statements are stringly typed in rocketry.</li> <li>You need more reliable and preditcable time based scheduling that logs when the next event is going to be triggered.</li> </ul> <p>When Rocketry might be a better choice:</p> <ul> <li>You need a task pipelining that is heavily cpu intensive.</li> <li>Your code is not yet asynchronous, or blocks the main thread.</li> <li>You are still using Pydantic v1.</li> </ul> <p>Note</p> <p>You can also asyncify your sync code, by running them in a threadpool executor. Libraries like <code>asyncer</code> or <code>anyio</code> might help you with that. Note that this won't truely make your code async, because async code are meant to only run on one thread, but still you get the job done with AioClock easily. It would be the fit solution if the library you use does not have an async alternative.</p>"},{"location":"alternative/#aioclock-vs-crontab","title":"AioClock vs Crontab","text":"<p>Crontab is a scheduler for Unix-like operating systems. It is light weight and it is able to run tasks (or jobs) periodically, ie. hourly, weekly or on fixed dates.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building a system and not just running individual scripts.</li> <li>You need task pipelining.</li> <li>You need more complex and custom scheduling.</li> <li>You are not familiar Unix-Linux or you work with Windows.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When Crontab might be a better choice:</p> <ul> <li>If you need a truly light weight solution.</li> <li>You are not familiar with Python.</li> <li>You only want to run scripts independently at given periods.</li> </ul>"},{"location":"alternative/#aioclock-vs-apscheduler","title":"AioClock vs APScheduler","text":"<p>APScheduler is a relatively simple scheduler library for Python. It provides Cron-style scheduling and some interval based scheduling.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building an automation system.</li> <li>You need more complex and customized scheduling.</li> <li>You need to pipeline tasks.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When APScheduler might be a better choice:</p> <ul> <li>You wish to have the tasks stored in a database (and not in Python code)</li> </ul> <p>Note</p> <p>In soon future, AioClock would also be able to store tasks in a database to let you scale out.</p>"},{"location":"alternative/#aioclock-vs-celery","title":"AioClock vs Celery","text":"<p>Celery is a task queue system meant for distributed execution and scheduling background tasks for web back-ends.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building an automation system.</li> <li>You need more complex and customized scheduling.</li> <li>You work with Windows.</li> <li>You want to fully control your broker behavior, and have high flexability.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When Celery might be a better choice:</p> <ul> <li>You are running background tasks for web servers.</li> <li>You are not very familiar with message brokers, and you need very easy solution that abstract away all details.</li> </ul> <p>Note</p> <p>Celery works via task queues but such mechanism could be implemented to AioClock as well by creating a <code>once trigger</code> that reads from queue. You may make this as decorator and even create new libraries using AioClock. For implementation details, see how to integrate a broker into AioClock App.</p>"},{"location":"alternative/#aioclock-vs-airflow","title":"AioClock vs Airflow","text":"<p>Airflow is a a workflow management system used heavily in data pipelines. It has a scheduler and a built-in monitor.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You work with Windows.</li> <li>You need something that is easy to set up and quick to get produtive with.</li> <li>You are building an application.</li> <li>You want more customization.</li> </ul> <p>When Airflow might be a better choice:</p> <ul> <li>You are building standard data pipelines.</li> <li>You would like to have more out-of-the-box.</li> <li>You need distributed execution.</li> <li>You work in data engineering.</li> </ul>"},{"location":"alternative/#aioclock-vs-faststream","title":"AioClock vs FastStream","text":"<p>FastStream is a powerful and easy-to-use Python framework for building asynchronous services interacting with event streams such as Apache Kafka, RabbitMQ, NATS and Redis.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You need more complex and customized scheduling.</li> <li>You need high flexability and low level APIs of your broker.</li> </ul> <p>When FastStream might be a better choice:</p> <ul> <li>You are not very familiar with message brokers, and you need very easy solution that abstract away all details.</li> <li>You need auto generated asyncapi documentation</li> <li>You are building a distributed data streaming application</li> </ul> <p>Note</p> <p>Note that you can use both beside each other, just like FastAPI. All you'd have to do is to serve both application at same time.</p>"},{"location":"api/app/","title":"Aioclock App","text":""},{"location":"api/app/#aioclock.app.AioClock","title":"AioClock","text":"<pre><code>AioClock()\n</code></pre> <p>AioClock is the main class that will be used to run the tasks. It will be responsible for running the tasks in the right order.</p> <p>Example:</p> <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\n@app.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n</code></pre> <p>To run the aioclock final app simply do:</p> <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\n# whatever next comes here\nawait app.serve()\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize AioClock instance.\n    No parameters are needed.\n    \"\"\"\n    self._groups: list[Group] = []\n    self._app_tasks: list[Task] = []\n</code></pre>"},{"location":"api/app/#aioclock.app.AioClock.dependencies","title":"dependencies  <code>property</code>","text":"<pre><code>dependencies\n</code></pre> <p>Dependencies provider that will be used to inject dependencies in tasks.</p>"},{"location":"api/app/#aioclock.app.AioClock.override_dependencies","title":"override_dependencies","text":"<pre><code>override_dependencies(\n    original: Callable[..., Any],\n    override: Callable[..., Any],\n) -&gt; None\n</code></pre> <p>Override a dependency with a new one.</p> <p>Example:</p> <pre><code>from aioclock import AioClock\n\ndef original_dependency():\n    return 1\n\ndef new_dependency():\n    return 2\n\napp = AioClock()\napp.override_dependencies(original=original_dependency, override=new_dependency)\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def override_dependencies(\n    self, original: Callable[..., Any], override: Callable[..., Any]\n) -&gt; None:\n    \"\"\"Override a dependency with a new one.\n\n    Example:\n\n    ```python\n    from aioclock import AioClock\n\n    def original_dependency():\n        return 1\n\n    def new_dependency():\n        return 2\n\n    app = AioClock()\n    app.override_dependencies(original=original_dependency, override=new_dependency)\n    ```\n\n    \"\"\"\n    self.dependencies.override(original, override)\n</code></pre>"},{"location":"api/app/#aioclock.app.AioClock.include_group","title":"include_group","text":"<pre><code>include_group(group: Group) -&gt; None\n</code></pre> <p>Include a group of tasks that will be run by AioClock. Example:</p> <pre><code>from aioclock import AioClock, Group, Once\n\napp = AioClock()\n\ngroup = Group()\n@group.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n\napp.include_group(group)\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def include_group(self, group: Group) -&gt; None:\n    \"\"\"Include a group of tasks that will be run by AioClock.\n    Example:\n\n    ```python\n    from aioclock import AioClock, Group, Once\n\n    app = AioClock()\n\n    group = Group()\n    @group.task(trigger=Once())\n    async def main():\n        print(\"Hello World\")\n\n    app.include_group(group)\n    ```\n    \"\"\"\n    self._groups.append(group)\n    return None\n</code></pre>"},{"location":"api/app/#aioclock.app.AioClock.task","title":"task","text":"<pre><code>task(*, trigger: BaseTrigger)\n</code></pre> <p>Decorator to add a task to the AioClock instance.</p> <p>Example:</p> <pre><code>from aioclock import AioClock, Once\n\napp = AioClock()\n\n@app.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def task(self, *, trigger: BaseTrigger):\n    \"\"\"Decorator to add a task to the AioClock instance.\n\n    Example:\n\n    ```python\n    from aioclock import AioClock, Once\n\n    app = AioClock()\n\n    @app.task(trigger=Once())\n    async def main():\n        print(\"Hello World\")\n    ```\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        async def wrapper(*args, **kwargs) -&gt; Any:\n            return await func(*args, **kwargs)\n\n        self._app_tasks.append(\n            Task(\n                func=inject(wrapper, dependency_overrides_provider=get_provider()),\n                trigger=trigger,\n            )\n        )\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/app/#aioclock.app.AioClock.serve","title":"serve  <code>async</code>","text":"<pre><code>serve() -&gt; None\n</code></pre> <p>Serves AioClock Run the tasks in the right order. First, run the startup tasks, then run the tasks, and finally run the shutdown tasks.</p> Source code in <code>aioclock/app.py</code> <pre><code>async def serve(self) -&gt; None:\n    \"\"\"\n    Serves AioClock\n    Run the tasks in the right order.\n    First, run the startup tasks, then run the tasks, and finally run the shutdown tasks.\n    \"\"\"\n\n    self.include_group(Group(tasks=self._app_tasks))\n    try:\n        await asyncio.gather(\n            *(task.run() for task in self._get_startup_task()), return_exceptions=False\n        )\n\n        await asyncio.gather(\n            *(group.run() for group in self._get_tasks()), return_exceptions=False\n        )\n    finally:\n        shutdown_tasks = self._get_shutdown_task()\n        await asyncio.gather(*(task.run() for task in shutdown_tasks), return_exceptions=False)\n</code></pre>"},{"location":"api/group/","title":"Group","text":""},{"location":"api/group/#aioclock.group.Group","title":"Group","text":"<pre><code>Group(*, tasks: Union[list[Task], None] = None)\n</code></pre> <p>Best use case is to have a good modularity and separation of concerns. For example, you can have a group of tasks that are responsible for sending emails. And another group of tasks that are responsible for sending notifications.</p> <p>Example: <pre><code>from aioclock import Group, AioClock, Forever\n\nemail_group = Group()\n\n# consider this as different file\n@email_group.task(trigger=Forever())\nasync def send_email():\n    ...\n\n# app.py\naio_clock = AioClock()\naio_clock.include_group(email_group)\n</code></pre></p> Source code in <code>aioclock/group.py</code> <pre><code>def __init__(self, *, tasks: Union[list[Task], None] = None):\n    \"\"\"\n    Group of tasks that will be run together.\n\n    Best use case is to have a good modularity and separation of concerns.\n    For example, you can have a group of tasks that are responsible for sending emails.\n    And another group of tasks that are responsible for sending notifications.\n\n    Example:\n    ```python\n\n    from aioclock import Group, AioClock, Forever\n\n    email_group = Group()\n\n    # consider this as different file\n    @email_group.task(trigger=Forever())\n    async def send_email():\n        ...\n\n    # app.py\n    aio_clock = AioClock()\n    aio_clock.include_group(email_group)\n    ```\n\n    \"\"\"\n    self._tasks: list[Task] = tasks or []\n</code></pre>"},{"location":"api/group/#aioclock.group.Group.task","title":"task","text":"<pre><code>task(*, trigger: BaseTrigger)\n</code></pre> <p>Function used to decorate tasks, to be registered inside AioClock.</p> <p>Example: <pre><code>from aioclock import Group, Forever\n@group.task(trigger=Forever())\nasync def send_email():\n    ...\n</code></pre></p> Source code in <code>aioclock/group.py</code> <pre><code>def task(self, *, trigger: BaseTrigger):\n    \"\"\"Function used to decorate tasks, to be registered inside AioClock.\n\n    Example:\n    ```python\n    from aioclock import Group, Forever\n    @group.task(trigger=Forever())\n    async def send_email():\n        ...\n    ```\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        @wraps(func)\n        async def wrapper(*args, **kwargs) -&gt; Any:\n            return await func(*args, **kwargs)\n\n        self._tasks.append(\n            Task(\n                func=inject(wrapper, dependency_overrides_provider=get_provider()),\n                trigger=trigger,\n            )\n        )\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/task/","title":"Task","text":""},{"location":"api/task/#aioclock.task.Task","title":"Task  <code>dataclass</code>","text":"<pre><code>Task(func: Callable[..., Any], trigger: BaseTrigger)\n</code></pre> <p>Task that will be run by AioClock. Which always has a function and a trigger. This is internally used, when you decorate your function with <code>aioclock.task</code>.</p>"},{"location":"api/task/#aioclock.task.Task.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable[..., Any]\n</code></pre> <p>Decorated function that will be run by AioClock.</p>"},{"location":"api/task/#aioclock.task.Task.trigger","title":"trigger  <code>instance-attribute</code>","text":"<pre><code>trigger: BaseTrigger\n</code></pre> <p>Trigger that will be used to run the function.</p>"},{"location":"api/task/#aioclock.task.Task.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Run the task, and handle the exceptions. If the task fails, log the error with exception, but keep running the tasks.</p> Source code in <code>aioclock/task.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Run the task, and handle the exceptions.\n    If the task fails, log the error with exception, but keep running the tasks.\n    \"\"\"\n    while self.trigger.should_trigger():\n        try:\n            next_trigger = await self.trigger.get_waiting_time_till_next_trigger()\n            if next_trigger is not None:\n                logger.info(f\"Triggering next task {self.func.__name__} in {next_trigger}\")\n            await self.trigger.trigger_next()\n            logger.debug(f\"Running task {self.func.__name__}\")\n            await self.func()\n        except Exception as error:\n            # Log the error, but keep running the tasks.\n            # don't crash the whole application.\n            logger.exception(f\"Error running task {self.func.__name__}: {error}\")\n</code></pre>"},{"location":"api/triggers/","title":"Triggers","text":""},{"location":"api/triggers/#aioclock.triggers.BaseTrigger","title":"BaseTrigger","text":"<p>             Bases: <code>BaseModel</code>, <code>ABC</code>, <code>Generic[TriggerTypeT]</code></p> <p>Base class for all triggers. A trigger is a way to determine when the event should be triggered. It can be based on time, or some other condition.</p> The way trigger are used is as follows <ol> <li>An async function which is a task, is decorated with framework, and trigger is the arguement for the decorator</li> <li><code>get_waiting_time_till_next_trigger</code> is called to get the time in seconds, after which the event should be triggered.</li> <li>If the time is not None, then it logs the time that is predicted for the event to be triggered.</li> <li><code>trigger_next</code> is called immidiately after that, which triggers the event.</li> </ol> <p>This is an example to implement a custom trigger, by yourself:</p> <pre><code>from aioclock.triggers import BaseTrigger\n\n\nclass Forever(BaseTrigger[Literal[\"Forever\"]]):\n    type_: Literal[\"Forever\"] = \"Forever\"\n\n    def should_trigger(self) -&gt; bool:\n        return True\n\n    async def trigger_next(self) -&gt; None:\n        return None\n\n    async def get_waiting_time_till_next_trigger(self):\n        if self.should_trigger():\n            return 0\n        return None\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_: TriggerTypeT\n</code></pre> <p>Type of the trigger. It is a string, which is used to identify the trigger's name. You can change the type by using <code>Generic</code> type when inheriting from <code>BaseTrigger</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.trigger_next","title":"trigger_next  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>trigger_next() -&gt; None\n</code></pre> <p><code>trigger_next</code> keep track of the event, and triggers the event. The function shall return when the event is triggered and should be executed.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>@abstractmethod\nasync def trigger_next(self) -&gt; None:\n    \"\"\"\n    `trigger_next` keep track of the event, and triggers the event.\n    The function shall return when the event is triggered and should be executed.\n    \"\"\"\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.should_trigger","title":"should_trigger","text":"<pre><code>should_trigger() -&gt; bool\n</code></pre> <p><code>should_trigger</code> checks if the event should be triggered or not. If not, then the event will not be triggered anymore. You can save the state of the trigger and task inside the instance, and then check if the event should be triggered or not. For instance, in <code>LoopCounter</code> trigger, it keeps track of the number of times the event has been triggered, and then checks if the event should be triggered or not.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>def should_trigger(self) -&gt; bool:\n    \"\"\"\n    `should_trigger` checks if the event should be triggered or not.\n    If not, then the event will not be triggered anymore.\n    You can save the state of the trigger and task inside the instance, and then check if the event should be triggered or not.\n    For instance, in `LoopCounter` trigger, it keeps track of the number of times the event has been triggered,\n    and then checks if the event should be triggered or not.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.get_waiting_time_till_next_trigger","title":"get_waiting_time_till_next_trigger  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_waiting_time_till_next_trigger() -&gt; Union[float, None]\n</code></pre> <p>Returns the time in seconds, after which the event should be triggered. Returns None, if the event should not trigger anymore.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>@abstractmethod\nasync def get_waiting_time_till_next_trigger(self) -&gt; Union[float, None]:\n    \"\"\"\n    Returns the time in seconds, after which the event should be triggered.\n    Returns None, if the event should not trigger anymore.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.Forever","title":"Forever","text":"<p>             Bases: <code>BaseTrigger[Literal[FOREVER]]</code></p> <p>A trigger that is always triggered imidiately.</p> <p>Example: <pre><code>    from aioclock import AioClock,\n\n    app = AioClock()\n\n    # instead of this:\n    async def my_task():\n        while True:\n            try:\n                await asyncio.sleep(3)\n                1/0\n            excpet DivisionByZero:\n                pass\n\n    # use this:\n    @app.task(trigger=Forever())\n    async def my_task():\n        await asyncio.sleep(3)\n        1/0\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.LoopController","title":"LoopController","text":"<p>             Bases: <code>BaseTrigger</code>, <code>ABC</code>, <code>Generic[TriggerTypeT]</code></p> <p>Base class for all triggers that have loop control.</p>"},{"location":"api/triggers/#aioclock.triggers.LoopController.type_","title":"type_  <code>instance-attribute</code>","text":"<pre><code>type_: TriggerTypeT\n</code></pre> <p>Type of the trigger. It is a string, which is used to identify the trigger's name. You can change the type by using <code>Generic</code> type when inheriting from <code>BaseTrigger</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.LoopController.max_loop_count","title":"max_loop_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_loop_count: Union[PositiveInt, None] = None\n</code></pre> <p>The maximum number of times the event should be triggered.</p> <p>If set to 3, then 4th time the event will not be triggered. If set to None, it will keep running forever.</p> <p>This is available for all triggers that inherit from <code>LoopController</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.Once","title":"Once","text":"<p>             Bases: <code>LoopController[Literal[ONCE]]</code></p> <p>A trigger that is triggered only once. It is used to trigger the event only once, and then stop.</p> <p>Example: <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\napp.task(trigger=Once())\nasync def task():\n    print(\"Hello World!\")\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.Once.max_loop_count","title":"max_loop_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_loop_count: PositiveInt = 1\n</code></pre> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger</p>"},{"location":"api/triggers/#aioclock.triggers.OnStartUp","title":"OnStartUp","text":"<p>             Bases: <code>LoopController[Literal[ON_START_UP]]</code></p> <p>Just like Once, but it triggers the event only once, when the application starts up.</p> <p>Example: <pre><code>from aioclock import AioClock, OnStartUp\napp = AioClock()\n\napp.task(trigger=OnStartUp())\nasync def task():\n    print(\"Hello World!\")\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.OnStartUp.max_loop_count","title":"max_loop_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_loop_count: PositiveInt = 1\n</code></pre> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.OnShutDown","title":"OnShutDown","text":"<p>             Bases: <code>LoopController[Literal[ON_SHUT_DOWN]]</code></p> <p>Just like Once, but it triggers the event only once, when the application shuts down.</p> <p>Example: <pre><code>from aioclock import AioClock, OnShutDown\napp = AioClock()\n\napp.task(trigger=OnShutDown())\nasync def task():\n    print(\"Hello World!\")\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.OnShutDown.max_loop_count","title":"max_loop_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_loop_count: PositiveInt = 1\n</code></pre> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.Every","title":"Every","text":"<p>             Bases: <code>LoopController[Literal[EVERY]]</code></p> <p>A trigger that is triggered every x time units.</p> <p>Example: <pre><code>from aioclock import AioClock, Every\napp = AioClock()\n\napp.task(trigger=Every(seconds=3))\nasync def task():\n    print(\"Hello World!\")\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.Every.first_run_strategy","title":"first_run_strategy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_run_strategy: Literal['immediate', 'wait'] = 'wait'\n</code></pre> <p>Strategy to use for the first run. If <code>immediate</code>, then the event will be triggered immediately,     and then wait for the time to trigger the event again. If <code>wait</code>, then the event will wait for the time to trigger the event for the first time.</p>"},{"location":"api/triggers/#aioclock.triggers.Every.seconds","title":"seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seconds: Union[PositiveNumber, None] = None\n</code></pre> <p>Seconds to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.Every.minutes","title":"minutes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minutes: Union[PositiveNumber, None] = None\n</code></pre> <p>Minutes to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.Every.hours","title":"hours  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hours: Union[PositiveNumber, None] = None\n</code></pre> <p>Hours to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.Every.days","title":"days  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>days: Union[PositiveNumber, None] = None\n</code></pre> <p>Days to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.Every.weeks","title":"weeks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weeks: Union[PositiveNumber, None] = None\n</code></pre> <p>Weeks to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.At","title":"At","text":"<p>             Bases: <code>LoopController[Literal[AT]]</code></p> <p>A trigger that is triggered at a specific time.</p> <p>Example: <pre><code>from aioclock import AioClock, At\n\napp = AioClock()\n\n@app.task(trigger=At(hour=12, minute=30, tz=\"Asia/Kolkata\"))\nasync def task():\n    print(\"Hello World!\")\n</code></pre></p>"},{"location":"api/triggers/#aioclock.triggers.At.second","title":"second  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>second: SecondT = 0\n</code></pre> <p>Second to trigger the event.</p>"},{"location":"api/triggers/#aioclock.triggers.At.minute","title":"minute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minute: MinuteT = 0\n</code></pre> <p>Minute to trigger the event.</p>"},{"location":"api/triggers/#aioclock.triggers.At.hour","title":"hour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hour: HourT = 0\n</code></pre> <p>Hour to trigger the event.</p>"},{"location":"api/triggers/#aioclock.triggers.At.at","title":"at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>at: EveryT = 'every day'\n</code></pre> <p>Day of week to trigger the event. You would get the in-line typing support when using the trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.At.tz","title":"tz  <code>instance-attribute</code>","text":"<pre><code>tz: str\n</code></pre> <p>Timzeon to use for the event.</p>"},{"location":"examples/brokers/","title":"Using with Message Brokers","text":"<p>You can basically run any tasks on aioclock, it could be your redis broker or other kind of brokers listening to a queue. The benefit of doing so, is that you don't need to worry about dependency injection, shutdown or startup event.</p> <p>AioClock offer you a unique easy way to spin up new services, without any overhead or perfomance issue!</p> <pre><code>from aioclock import AioClock, Forever, OnShutDown\nfrom functools import lru_cache\nfrom your_module import BrokerType\n\napp = AioClock()\n\n# your singleton redis instance\n@lru_cache\ndef get_redis() -&gt; BrokerType:\n    ...\n\n\n@app.task(trigger=Forever())\nasync def read_message_queue(redis: BrokerType = Depends(get_redis)):\n    async for message in redis.listen(\"...\"):\n        ...\n\n\n@app.task(trigger=OnShutDown())\nasync def shutdown_event(redis: BrokerType = Depends(get_redis)):\n    await redis.disconnect()\n</code></pre> <p>One other way to do this, is to implement a trigger that automatically execute the function. But to do so, I basically need to wrap redis in my own library, and that's not good for some reasons:</p> <ol> <li>Complexity of framework increases.</li> <li>Is not realy flexible, because native library and client are always way more flexible. I end up writing something like <code>Celery</code>.</li> <li>The architecture I choose to handle interactions with broker may not satisfy your requirement.</li> </ol> <p>This repository is an example how you can write a message queue in aioclock.</p>"},{"location":"examples/fastapi/","title":"Using with FastAPI","text":"<p>To run AioClock with FastAPI, you can run it in the background with FastAPI lifespan, next to your asgi.</p> <pre><code>from aioclock import AioClock\nfrom fastapi import FastAPI\nimport asyncio\n\nclock_app = AioClock()\n\nasync def lifespan(app: FastAPI):\n    task = asyncio.create_task(clock_app.serve())\n    yield\n\n    try:\n        task.cancel()\n        await task\n    except asyncio.CancelledError:\n        ...\n\napp = FastAPI(lifespan=lifespan)\n</code></pre> <p>This setup is not recommended at all</p> <p>Running AioClock with FastAPI is not a good practice in General, because: FastAPI is a framework to write stateless API, but aioclock is still stateful component in your architecture. In simpler terms, it means if you have 5 instances of aioclock running, they produce 5x tasks than you intended. So you cannot easily scale up horizontally by adding more aioclock power!</p> <p>Even in this case, if you serve FastAPI with multiple processes, you end up having one aioclock per process!</p> <p>What I suggest doing is to spin one new service, that is responsible for processing the periodic tasks. Try to avoid periodic tasks in general, but sometimes it's not easy to do so.</p>"}]}