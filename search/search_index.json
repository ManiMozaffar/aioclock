{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AioClock","text":""},{"location":"#the-principle","title":"The Principle","text":"<p>Scheduling is annoying, stateful and hard to scale. But not anymore! AioClock is here as an asyncio-based scheduling framework designed for execution of periodic task with integrated support for dependency injection, enabling efficient and flexiable task management.</p> <p>Aioclock offers:</p> <ul> <li>Async: 100% Async, very light, fast and resource friendly</li> <li>Scheduling: Keep scheduling tasks for you</li> <li>Group: Group your task, for better code maintainability</li> <li>Trigger: Already defined and easily extendable triggers, to trigger your scheduler to be started</li> <li>Easy syntax: Library's syntax is very easy and enjoyable, no confusing hierarchy</li> <li>Pydantic v2 validation: Validate all your trigger on startup using pydantic 2. Fastest to fail possible!</li> <li>Soon: Running the task dispatcher (scheduler) on different process by default, so CPU intensive stuff on task won't delay the scheduling</li> <li>Soon: Backend support, to allow horizontal scalling, by synchronizing, maybe using Redis</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To Install aioclock, simply do</p> <pre><code>pip install aioclock\n</code></pre> <p>AioClock is very user friendly and easy to use, it's type stated library to use easily. AioClock always have a trigger, that trigger the events.</p> <pre><code>import asyncio\n\nfrom aioclock import AioClock, At, Depends, Every, Forever, Once, OnShutDown, OnStartUp\nfrom aioclock.group import Group\n\n# groups.py\ngroup = Group()\n\n\ndef more_useless_than_me():\n    return \"I'm a dependency. I'm more useless than a screen door on a submarine.\"\n\n\n@group.task(trigger=Every(seconds=10))\nasync def every():\n    print(\"Every 10 seconds, I make a quantum leap. Where will I land next?\")\n\n\n@group.task(trigger=At(tz=\"UTC\", hour=0, minute=0, second=0))\nasync def at():\n    print(\n        \"When the clock strikes midnight... I turn into a pumpkin. Just kidding, I run this task!\"\n    )\n\n\n@group.task(trigger=Forever())\nasync def forever(val: str = Depends(more_useless_than_me)):\n    await asyncio.sleep(2)\n    print(\"Heartbeat detected. Still not a zombie. Will check again in a bit.\")\n    assert val == \"I'm a dependency. I'm more useless than a screen door on a submarine.\"\n\n\n@group.task(trigger=Once())\nasync def once():\n    print(\"Just once, I get to say something. Here it goes... I love lamp.\")\n\n\n# app.py\napp = AioClock()\napp.include_group(group)\n\n\n@app.task(trigger=OnStartUp())\nasync def startup():\n    print(\n        \"Welcome to the Async Chronicles! Did you know a group of unicorns is called a blessing? Well, now you do!\"\n    )\n\n\n@app.task(trigger=OnShutDown())\nasync def shutdown():\n    print(\"Going offline. Remember, if your code is running, you better go catch it!\")\n\n\n# main.py\nif __name__ == \"__main__\":\n    asyncio.run(app.serve())\n</code></pre>"},{"location":"alternative/","title":"AioClock VS Alternatives","text":"<p>There are other alternatives for scheduling as well. This section contains comparisons between AioClock and other scheduling tools. Credit to Rocketry library, as the comparison is inspired by that.</p> <p>Features unique for AioClock:</p> <ul> <li>Simplicity: With being super-simple, it's very easy to extend the library as you wish, which is not the usual case with other solutions!</li> <li>Trigger-based scheduling: Trigger based scheduling allows flexibility, making it very easy to run a task at a certain time in future.</li> <li>Dependency Injection System: Just like FastAPI, AioClock has a very similiar injection system which you can use to decouple your dependency.</li> <li>Declarative Syntax: AioClock promotes declarative syntax which makes the library easy to use.</li> </ul>"},{"location":"alternative/#aioclock-vs-rocketry","title":"AioClock vs Rocketry","text":"<p>Rocketry is a modern statement-based scheduling framework for Python. It is simple, clean and extensive. It is suitable for small and big projects.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You need a truly light weight solution.</li> <li>You are using Pydantic v2.</li> <li>Type safety is important to you. All triggers are type safe, but some statements are stringly typed in rocketry.</li> <li>You need more reliable and preditcable time based scheduling that logs when the next event is going to be triggered.</li> </ul> <p>When Rocketry might be a better choice:</p> <ul> <li>You need a task pipelining that is heavily cpu intensive.</li> <li>Your code is not yet asynchronous, or blocks the main thread.</li> <li>You are still using Pydantic v1.</li> </ul> <p>Note</p> <p>You can also asyncify your sync code, by running them in a threadpool executor. Libraries like <code>asyncer</code> or <code>anyio</code> might help you with that. Note that this won't truely make your code async, because async code are meant to only run on one thread, but still you get the job done with AioClock easily. It would be the fit solution if the library you use does not have an async alternative.</p>"},{"location":"alternative/#aioclock-vs-crontab","title":"AioClock vs Crontab","text":"<p>Crontab is a scheduler for Unix-like operating systems. It is light weight and it is able to run tasks (or jobs) periodically, ie. hourly, weekly or on fixed dates.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building a system and not just running individual scripts.</li> <li>You need task pipelining.</li> <li>You need more complex and custom scheduling.</li> <li>You are not familiar Unix-Linux or you work with Windows.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When Crontab might be a better choice:</p> <ul> <li>If you need a truly light weight solution.</li> <li>You are not familiar with Python.</li> <li>You only want to run scripts independently at given periods.</li> </ul>"},{"location":"alternative/#aioclock-vs-apscheduler","title":"AioClock vs APScheduler","text":"<p>APScheduler is a relatively simple scheduler library for Python. It provides Cron-style scheduling and some interval based scheduling.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building an automation system.</li> <li>You need more complex and customized scheduling.</li> <li>You need to pipeline tasks.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When APScheduler might be a better choice:</p> <ul> <li>You wish to have the tasks stored in a database (and not in Python code)</li> </ul> <p>Note</p> <p>In soon future, AioClock would also be able to store tasks in a database to let you scale out.</p>"},{"location":"alternative/#aioclock-vs-celery","title":"AioClock vs Celery","text":"<p>Celery is a task queue system meant for distributed execution and scheduling background tasks for web back-ends.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You are building an automation system.</li> <li>You need more complex and customized scheduling.</li> <li>You work with Windows.</li> <li>You want to fully control your broker behavior, and have high flexability.</li> <li>You need dependency injection on top of your framework layer.</li> </ul> <p>When Celery might be a better choice:</p> <ul> <li>You are running background tasks for web servers.</li> <li>You are not very familiar with message brokers, and you need very easy solution that abstract away all details.</li> </ul> <p>Note</p> <p>Celery works via task queues but such mechanism could be implemented to AioClock as well by creating a <code>once trigger</code> that reads from queue. You may make this as decorator and even create new libraries using AioClock. For implementation details, see how to integrate a broker into AioClock App.</p>"},{"location":"alternative/#aioclock-vs-airflow","title":"AioClock vs Airflow","text":"<p>Airflow is a a workflow management system used heavily in data pipelines. It has a scheduler and a built-in monitor.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You work with Windows.</li> <li>You need something that is easy to set up and quick to get produtive with.</li> <li>You are building an application.</li> <li>You want more customization.</li> </ul> <p>When Airflow might be a better choice:</p> <ul> <li>You are building standard data pipelines.</li> <li>You would like to have more out-of-the-box.</li> <li>You need distributed execution.</li> <li>You work in data engineering.</li> </ul>"},{"location":"alternative/#aioclock-vs-faststream","title":"AioClock vs FastStream","text":"<p>FastStream is a powerful and easy-to-use Python framework for building asynchronous services interacting with event streams such as Apache Kafka, RabbitMQ, NATS and Redis.</p> <p>When AioClock might be a better choice:</p> <ul> <li>You need more complex and customized scheduling.</li> <li>You need high flexability and low level APIs of your broker.</li> </ul> <p>When FastStream might be a better choice:</p> <ul> <li>You are not very familiar with message brokers, and you need very easy solution that abstract away all details.</li> <li>You need auto generated asyncapi documentation</li> <li>You are building a distributed data streaming application</li> </ul> <p>Note</p> <p>Note that you can use both beside each other, just like FastAPI. All you'd have to do is to serve both application at same time.</p>"},{"location":"api/external_api/","title":"External API","text":"<p>External API of the aioclock package, that can be used to interact with the AioClock instance. This module could be very useful if you intend to use aioclock in a web application or a CLI tool.</p> <p>Other tools and extension are written from this tool.</p> <p>Note when writing to aioclock API and changing its state.</p> <p>Right now the state of AioClock instance is on the memory level, so if you write an API and change a task's trigger time, it will not persist. In future we might store the state of AioClock instance in a database, so that it always remains same. But this is a bit tricky and implicit because then your code gets ignored and database is preferred over the database. For now you may consider it as a way to change something without redeploying the application, but it is not very recommended to write.</p>"},{"location":"api/external_api/#aioclock.api.TaskMetadata","title":"TaskMetadata","text":"<p>             Bases: <code>BaseModel</code></p> <p>Metadata of the task that is included in the AioClock instance.</p>"},{"location":"api/external_api/#aioclock.api.TaskMetadata.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: UUID\n</code></pre> <p>Task ID that is unique for each task, and changes every time you run the aioclock app. In future we might store task ID in a database, so that it always remains same.</p>"},{"location":"api/external_api/#aioclock.api.TaskMetadata.trigger","title":"trigger  <code>instance-attribute</code>","text":"<pre><code>trigger: Union[TriggerT, Any]\n</code></pre> <p>Trigger that is used to run the task, type is also any to ease implementing new triggers.</p>"},{"location":"api/external_api/#aioclock.api.run_specific_task","title":"run_specific_task  <code>async</code>","text":"<pre><code>run_specific_task(task_id: UUID, app: AioClock)\n</code></pre> <p>Run a specific task immediately by its ID, from the AioClock instance.</p> Example <pre><code>from aioclock import  AioClock, Once\nfrom aioclock.api import run_specific_task\n\napp = AioClock()\n\n@app.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n\nasync def some_other_func():\n    await run_specific_task(app._tasks[0].id, app)\n</code></pre> Source code in <code>aioclock/api.py</code> <pre><code>async def run_specific_task(task_id: UUID, app: AioClock):\n    \"\"\"Run a specific task immediately by its ID, from the AioClock instance.\n\n    Example:\n        ```python\n        from aioclock import  AioClock, Once\n        from aioclock.api import run_specific_task\n\n        app = AioClock()\n\n        @app.task(trigger=Once())\n        async def main():\n            print(\"Hello World\")\n\n        async def some_other_func():\n            await run_specific_task(app._tasks[0].id, app)\n        ```\n\n    \"\"\"\n    task = next((task for task in app._tasks if task.id == task_id), None)\n    if not task:\n        raise TaskIdNotFound\n    return await run_with_injected_deps(task.func)\n</code></pre>"},{"location":"api/external_api/#aioclock.api.run_with_injected_deps","title":"run_with_injected_deps  <code>async</code>","text":"<pre><code>run_with_injected_deps(\n    func: Callable[P, Awaitable[T]]\n) -&gt; T\n</code></pre> <p>Runs an aioclock decorated function, with all the dependencies injected.</p> Example <pre><code>from aioclock import Once, AioClock, Depends\nfrom aioclock.api import run_with_injected_deps\n\napp = AioClock()\n\ndef some_dependency():\n    return 1\n\n@app.task(trigger=Once())\nasync def main(bar: int = Depends(some_dependency)):\n    print(\"Hello World\")\n    return bar\n\nasync def some_other_func():\n    foo = await run_with_injected_deps(main)\n    assert foo == 1\n</code></pre> Source code in <code>aioclock/api.py</code> <pre><code>async def run_with_injected_deps(func: Callable[P, Awaitable[T]]) -&gt; T:\n    \"\"\"Runs an aioclock decorated function, with all the dependencies injected.\n\n    Example:\n        ```python\n        from aioclock import Once, AioClock, Depends\n        from aioclock.api import run_with_injected_deps\n\n        app = AioClock()\n\n        def some_dependency():\n            return 1\n\n        @app.task(trigger=Once())\n        async def main(bar: int = Depends(some_dependency)):\n            print(\"Hello World\")\n            return bar\n\n        async def some_other_func():\n            foo = await run_with_injected_deps(main)\n            assert foo == 1\n        ```\n\n    \"\"\"\n    return await inject(func, dependency_overrides_provider=get_provider())()  # type: ignore\n</code></pre>"},{"location":"api/external_api/#aioclock.api.get_metadata_of_all_tasks","title":"get_metadata_of_all_tasks  <code>async</code>","text":"<pre><code>get_metadata_of_all_tasks(\n    app: AioClock,\n) -&gt; list[TaskMetadata]\n</code></pre> <p>Get metadata of all tasks that are included in the AioClock instance.</p> Example <pre><code>from aioclock import AioClock, Once\nfrom aioclock.api import get_metadata_of_all_tasks\n\napp = AioClock()\n@app.task(trigger=Once())\nasync def main(): ...\n\nmetadata = await get_metadata_of_all_tasks(app)\n</code></pre> Source code in <code>aioclock/api.py</code> <pre><code>async def get_metadata_of_all_tasks(app: AioClock) -&gt; list[TaskMetadata]:\n    \"\"\"Get metadata of all tasks that are included in the AioClock instance.\n\n    Example:\n        ```python\n        from aioclock import AioClock, Once\n        from aioclock.api import get_metadata_of_all_tasks\n\n        app = AioClock()\n        @app.task(trigger=Once())\n        async def main(): ...\n\n        metadata = await get_metadata_of_all_tasks(app)\n        ```\n    \"\"\"\n    return [\n        TaskMetadata(\n            id=task.id,\n            trigger=task.trigger,\n            task_name=task.func.__name__,\n        )\n        for task in app._get_tasks(exclude_type=set())\n    ]\n</code></pre>"},{"location":"api/getting_started/","title":"AioClock Application","text":"<p>To initialize the AioClock instance, you need to import the AioClock class from the aioclock module. AioClock class represent the aioclock, and handle the tasks and groups that will be run by the aioclock.</p> <p>Another way to modulize your code is to use <code>Group</code> which is kinda the same idea as router in web frameworks.</p>"},{"location":"api/getting_started/#aioclock.app.AioClock","title":"AioClock","text":"<pre><code>AioClock()\n</code></pre> <p>AioClock is the main class that will be used to run the tasks. It will be responsible for running the tasks in the right order.</p> Example <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\n@app.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n</code></pre> <p>To run the aioclock final app simply do:</p> Example <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\n# whatever next comes here\nawait app.serve()\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize AioClock instance.\n    No parameters are needed.\n    \"\"\"\n    self._groups: list[Group] = []\n    self._app_tasks: list[Task] = []\n</code></pre>"},{"location":"api/getting_started/#aioclock.app.AioClock.dependencies","title":"dependencies  <code>property</code>","text":"<pre><code>dependencies\n</code></pre> <p>Dependencies provider that will be used to inject dependencies in tasks.</p>"},{"location":"api/getting_started/#aioclock.app.AioClock.override_dependencies","title":"override_dependencies","text":"<pre><code>override_dependencies(\n    original: Callable[..., Any],\n    override: Callable[..., Any],\n) -&gt; None\n</code></pre> <p>Override a dependency with a new one.</p> Example <pre><code>from aioclock import AioClock\n\ndef original_dependency():\n    return 1\n\ndef new_dependency():\n    return 2\n\napp = AioClock()\napp.override_dependencies(original=original_dependency, override=new_dependency)\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def override_dependencies(\n    self, original: Callable[..., Any], override: Callable[..., Any]\n) -&gt; None:\n    \"\"\"Override a dependency with a new one.\n\n    Example:\n        ```python\n        from aioclock import AioClock\n\n        def original_dependency():\n            return 1\n\n        def new_dependency():\n            return 2\n\n        app = AioClock()\n        app.override_dependencies(original=original_dependency, override=new_dependency)\n        ```\n\n    \"\"\"\n    self.dependencies.override(original, override)\n</code></pre>"},{"location":"api/getting_started/#aioclock.app.AioClock.include_group","title":"include_group","text":"<pre><code>include_group(group: Group) -&gt; None\n</code></pre> <p>Include a group of tasks that will be run by AioClock.</p> Example <pre><code>from aioclock import AioClock, Group, Once\n\napp = AioClock()\n\ngroup = Group()\n@group.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n\napp.include_group(group)\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def include_group(self, group: Group) -&gt; None:\n    \"\"\"Include a group of tasks that will be run by AioClock.\n\n    Example:\n        ```python\n        from aioclock import AioClock, Group, Once\n\n        app = AioClock()\n\n        group = Group()\n        @group.task(trigger=Once())\n        async def main():\n            print(\"Hello World\")\n\n        app.include_group(group)\n        ```\n    \"\"\"\n    self._groups.append(group)\n    return None\n</code></pre>"},{"location":"api/getting_started/#aioclock.app.AioClock.task","title":"task","text":"<pre><code>task(*, trigger: BaseTrigger)\n</code></pre> <p>Decorator to add a task to the AioClock instance.</p> <p>Example:</p> <pre><code>```python\nfrom aioclock import AioClock, Once\n\napp = AioClock()\n\n@app.task(trigger=Once())\nasync def main():\n    print(\"Hello World\")\n```\n</code></pre> Source code in <code>aioclock/app.py</code> <pre><code>def task(self, *, trigger: BaseTrigger):\n    \"\"\"Decorator to add a task to the AioClock instance.\n\n    Example:\n\n        ```python\n        from aioclock import AioClock, Once\n\n        app = AioClock()\n\n        @app.task(trigger=Once())\n        async def main():\n            print(\"Hello World\")\n        ```\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[T]]) -&gt; Callable[P, Awaitable[T]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n            return await func(*args, **kwargs)\n\n        self._app_tasks.append(\n            Task(\n                func=inject(wrapper, dependency_overrides_provider=get_provider()),\n                trigger=trigger,\n            )\n        )\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/getting_started/#aioclock.app.AioClock.serve","title":"serve  <code>async</code>","text":"<pre><code>serve() -&gt; None\n</code></pre> <p>Serves AioClock Run the tasks in the right order. First, run the startup tasks, then run the tasks, and finally run the shutdown tasks.</p> Source code in <code>aioclock/app.py</code> <pre><code>async def serve(self) -&gt; None:\n    \"\"\"\n    Serves AioClock\n    Run the tasks in the right order.\n    First, run the startup tasks, then run the tasks, and finally run the shutdown tasks.\n    \"\"\"\n\n    self.include_group(Group(tasks=self._app_tasks))\n    try:\n        await asyncio.gather(\n            *(task.run() for task in self._get_startup_task()), return_exceptions=False\n        )\n\n        await asyncio.gather(\n            *(group.run() for group in self._get_tasks()), return_exceptions=False\n        )\n    finally:\n        shutdown_tasks = self._get_shutdown_task()\n        await asyncio.gather(*(task.run() for task in shutdown_tasks), return_exceptions=False)\n</code></pre>"},{"location":"api/getting_started/#aioclock.group.Group","title":"Group","text":"<pre><code>Group(*, tasks: Union[list[Task], None] = None)\n</code></pre> <p>Best use case is to have a good modularity and separation of concerns. For example, you can have a group of tasks that are responsible for sending emails. And another group of tasks that are responsible for sending notifications.</p> Example <pre><code>from aioclock import Group, AioClock, Forever\n\nemail_group = Group()\n\n# consider this as different file\n@email_group.task(trigger=Forever())\nasync def send_email():\n    ...\n\n# app.py\naio_clock = AioClock()\naio_clock.include_group(email_group)\n</code></pre> Source code in <code>aioclock/group.py</code> <pre><code>def __init__(self, *, tasks: Union[list[Task], None] = None):\n    \"\"\"\n    Group of tasks that will be run together.\n\n    Best use case is to have a good modularity and separation of concerns.\n    For example, you can have a group of tasks that are responsible for sending emails.\n    And another group of tasks that are responsible for sending notifications.\n\n    Example:\n        ```python\n\n        from aioclock import Group, AioClock, Forever\n\n        email_group = Group()\n\n        # consider this as different file\n        @email_group.task(trigger=Forever())\n        async def send_email():\n            ...\n\n        # app.py\n        aio_clock = AioClock()\n        aio_clock.include_group(email_group)\n        ```\n\n    \"\"\"\n    self._tasks: list[Task] = tasks or []\n</code></pre>"},{"location":"api/getting_started/#aioclock.group.Group.task","title":"task","text":"<pre><code>task(*, trigger: BaseTrigger)\n</code></pre> <p>Function used to decorate tasks, to be registered inside AioClock.</p> Example <pre><code>from aioclock import Group, Forever\n@group.task(trigger=Forever())\nasync def send_email():\n    ...\n</code></pre> Source code in <code>aioclock/group.py</code> <pre><code>def task(self, *, trigger: BaseTrigger):\n    \"\"\"Function used to decorate tasks, to be registered inside AioClock.\n\n    Example:\n        ```python\n        from aioclock import Group, Forever\n        @group.task(trigger=Forever())\n        async def send_email():\n            ...\n        ```\n    \"\"\"\n\n    def decorator(func: Callable[P, Awaitable[T]]) -&gt; Callable[P, Awaitable[T]]:\n        @wraps(func)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n            return await func(*args, **kwargs)\n\n        self._tasks.append(\n            Task(\n                func=inject(wrapper, dependency_overrides_provider=get_provider()),\n                trigger=trigger,\n            )\n        )\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/plugin/","title":"Plugins (FastAPI included)","text":"<p>Extensions for aioclock.</p> <p>AioClock is very extensible, and you can add your own extensions to it. The extension would allow you to interact with your AioClock instance, from different layers of your application. For instance, the FastAPI plugin allows you to run a specific task immediately from an HTTP API, or see your tasks in an HTTP API, and when they are going to run next.</p> <p>FastAPI extension to manage the tasks of the AioClock instance in HTTP Layer.</p> Use cases <ul> <li>Expose the tasks of the AioClock instance in an HTTP API.</li> <li>Show to your client which task is going to be run next, and at which time.</li> <li>Run a specific task from an HTTP API immidiately if needed.</li> </ul> <p>To use FastAPI Extension, please make sure you do <code>pip install aioclock[fastapi]</code>.</p>"},{"location":"api/plugin/#aioclock.ext.fastapi.make_fastapi_router","title":"make_fastapi_router","text":"<pre><code>make_fastapi_router(\n    aioclock: AioClock,\n    router: Union[APIRouter, None] = None,\n)\n</code></pre> <p>Make a FastAPI router that exposes the tasks of the AioClock instance and its external python API in HTTP Layer. You can pass a router to this function, and have dependencies injected in the router, or any authorization logic that you want to have.</p> Example <pre><code>import asyncio\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom aioclock import AioClock\nfrom aioclock.ext.fastapi import make_fastapi_router\nfrom aioclock.triggers import Every, OnStartUp\n\nclock_app = AioClock()\n\n\n@clock_app.task(trigger=OnStartUp())\nasync def startup():\n    print(\"Starting...\")\n\n\n@clock_app.task(trigger=Every(seconds=3600))\nasync def foo():\n    print(\"Foo is processing...\")\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    task = asyncio.create_task(clock_app.serve())\n    yield\n\n    try:\n        task.cancel()\n        await task\n    except asyncio.CancelledError:\n        ...\n\n\napp = FastAPI(lifespan=lifespan)\napp.include_router(make_fastapi_router(clock_app))\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app)\n</code></pre> Source code in <code>aioclock/ext/fastapi.py</code> <pre><code>def make_fastapi_router(aioclock: AioClock, router: Union[APIRouter, None] = None):\n    \"\"\"Make a FastAPI router that exposes the tasks of the AioClock instance and its external python API in HTTP Layer.\n    You can pass a router to this function, and have dependencies injected in the router, or any authorization logic that you want to have.\n\n    Example:\n        ```python\n        import asyncio\n        from contextlib import asynccontextmanager\n\n        from fastapi import FastAPI\n\n        from aioclock import AioClock\n        from aioclock.ext.fastapi import make_fastapi_router\n        from aioclock.triggers import Every, OnStartUp\n\n        clock_app = AioClock()\n\n\n        @clock_app.task(trigger=OnStartUp())\n        async def startup():\n            print(\"Starting...\")\n\n\n        @clock_app.task(trigger=Every(seconds=3600))\n        async def foo():\n            print(\"Foo is processing...\")\n\n\n        @asynccontextmanager\n        async def lifespan(app: FastAPI):\n            task = asyncio.create_task(clock_app.serve())\n            yield\n\n            try:\n                task.cancel()\n                await task\n            except asyncio.CancelledError:\n                ...\n\n\n        app = FastAPI(lifespan=lifespan)\n        app.include_router(make_fastapi_router(clock_app))\n\n        if __name__ == \"__main__\":\n            import uvicorn\n\n            uvicorn.run(app)\n        ```\n    \"\"\"\n    router = router or APIRouter()\n\n    @router.get(\"/tasks\")\n    async def get_tasks() -&gt; list[TaskMetadata]:\n        return await get_metadata_of_all_tasks(aioclock)\n\n    @router.post(\"/task/{task_id}\")\n    async def run_task(task_id: UUID):\n        try:\n            await run_specific_task(task_id, aioclock)\n        except TaskIdNotFound:\n            raise HTTPException(status_code=404, detail=\"Task not found\")\n\n    return router\n</code></pre>"},{"location":"api/task/","title":"Task","text":"<p>Aioclock wrap your functions with a task object, and append the task to the list of tasks in the AioClock instance. After collecting all the tasks from decorated functions, aioclock serve them in order it has to be (startup, normal, shutdown).</p> <p>These tasks keep running forever until the trigger's method <code>should_trigger</code> returns False.</p>"},{"location":"api/task/#aioclock.task.Task","title":"Task  <code>dataclass</code>","text":"<pre><code>Task(\n    func: Callable[..., Awaitable[Any]],\n    trigger: BaseTrigger,\n    id: UUID = uuid4(),\n)\n</code></pre> <p>Task that will be run by AioClock. Which always has a function and a trigger. This is internally used, when you decorate your function with <code>aioclock.task</code>.</p>"},{"location":"api/task/#aioclock.task.Task.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable[..., Awaitable[Any]]\n</code></pre> <p>Decorated function that will be run by AioClock.</p>"},{"location":"api/task/#aioclock.task.Task.trigger","title":"trigger  <code>instance-attribute</code>","text":"<pre><code>trigger: BaseTrigger\n</code></pre> <p>Trigger that will be used to run the function.</p>"},{"location":"api/task/#aioclock.task.Task.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UUID = field(default_factory=uuid4)\n</code></pre> <p>Task ID that is unique for each task, and changes every time you run the aioclock app. In future we might store task ID in a database, so that it always remains same.</p>"},{"location":"api/task/#aioclock.task.Task.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Run the task, and handle the exceptions. If the task fails, log the error with exception, but keep running the tasks.</p> Source code in <code>aioclock/task.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Run the task, and handle the exceptions.\n    If the task fails, log the error with exception, but keep running the tasks.\n    \"\"\"\n    while self.trigger.should_trigger():\n        try:\n            next_trigger = await self.trigger.get_waiting_time_till_next_trigger()\n            if next_trigger is not None:\n                logger.info(f\"Triggering next task {self.func.__name__} in {next_trigger}\")\n                self.trigger.expected_trigger_time = datetime.now(UTC) + timedelta(\n                    seconds=next_trigger\n                )\n            await self.trigger.trigger_next()\n            logger.debug(f\"Running task {self.func.__name__}\")\n            await self.func()\n        except Exception as error:\n            # Log the error, but keep running the tasks.\n            # don't crash the whole application.\n            logger.exception(f\"Error running task {self.func.__name__}: {error}\")\n\n    self.trigger.expected_trigger_time = None\n</code></pre>"},{"location":"api/triggers/","title":"Triggers","text":"<p>Triggers are used to determine when the event should be triggered. It can be based on time, or some other condition. You can create custom triggers by inheriting from <code>BaseTrigger</code> class.</p> <p>Don't run CPU intensitve or thread-block IO task </p> <p>AioClock's trigger are all running in async, only on one CPU. So, if you run a CPU intensive task, or a task that blocks the thread, then it will block the entire event loop. If you have a sync IO task, then it's recommended to use <code>run_in_executor</code> to run the task in a separate thread. Or use similiar libraries like <code>asyncer</code> or <code>trio</code> to run the task in a separate thread.</p>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger","title":"BaseTrigger","text":"<p>             Bases: <code>BaseModel</code>, <code>ABC</code>, <code>Generic[TriggerTypeT]</code></p> <p>Base class for all triggers. A trigger is a way to determine when the event should be triggered. It can be based on time, or some other condition.</p> The way trigger are used is as follows <ol> <li>An async function which is a task, is decorated with framework, and trigger is the arguement for the decorator</li> <li><code>get_waiting_time_till_next_trigger</code> is called to get the time in seconds, after which the event should be triggered.</li> <li>If the time is not None, then it logs the time that is predicted for the event to be triggered.</li> <li><code>trigger_next</code> is called immidiately after that, which triggers the event.</li> </ol> <p>You can create trigger by yourself, by inheriting from <code>BaseTrigger</code> class.</p> Example <pre><code>from aioclock.triggers import BaseTrigger\n\n\nclass Forever(BaseTrigger[Literal[\"Forever\"]]):\n    type_: Literal[\"Forever\"] = \"Forever\"\n\n    def should_trigger(self) -&gt; bool:\n        return True\n\n    async def trigger_next(self) -&gt; None:\n        return None\n\n    async def get_waiting_time_till_next_trigger(self):\n        if self.should_trigger():\n            return 0\n        return None\n</code></pre> <p>Attributes:</p> Name Type Description <code>type_</code> <code>TriggerTypeT</code> <p>Type of the trigger. It is a string, which is used to identify the trigger's name. You can change the type by using <code>Generic</code> type when inheriting from <code>BaseTrigger</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.trigger_next","title":"trigger_next  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>trigger_next() -&gt; None\n</code></pre> <p><code>trigger_next</code> keep track of the event, and triggers the event. The function shall return when the event is triggered and should be executed.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>@abstractmethod\nasync def trigger_next(self) -&gt; None:\n    \"\"\"\n    `trigger_next` keep track of the event, and triggers the event.\n    The function shall return when the event is triggered and should be executed.\n    \"\"\"\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.should_trigger","title":"should_trigger","text":"<pre><code>should_trigger() -&gt; bool\n</code></pre> <p><code>should_trigger</code> checks if the event should be triggered or not. If not, then the event will not be triggered anymore. You can save the state of the trigger and task inside the instance, and then check if the event should be triggered or not. For instance, in <code>LoopCounter</code> trigger, it keeps track of the number of times the event has been triggered, and then checks if the event should be triggered or not.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>def should_trigger(self) -&gt; bool:\n    \"\"\"\n    `should_trigger` checks if the event should be triggered or not.\n    If not, then the event will not be triggered anymore.\n    You can save the state of the trigger and task inside the instance, and then check if the event should be triggered or not.\n    For instance, in `LoopCounter` trigger, it keeps track of the number of times the event has been triggered,\n    and then checks if the event should be triggered or not.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.BaseTrigger.get_waiting_time_till_next_trigger","title":"get_waiting_time_till_next_trigger  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_waiting_time_till_next_trigger() -&gt; Union[float, None]\n</code></pre> <p>Returns the time in seconds, after which the event should be triggered. Returns None, if the event should not trigger anymore.</p> Source code in <code>aioclock/triggers.py</code> <pre><code>@abstractmethod\nasync def get_waiting_time_till_next_trigger(self) -&gt; Union[float, None]:\n    \"\"\"\n    Returns the time in seconds, after which the event should be triggered.\n    Returns None, if the event should not trigger anymore.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/triggers/#aioclock.triggers.Forever","title":"Forever","text":"<p>             Bases: <code>BaseTrigger[Literal[FOREVER]]</code></p> <p>A trigger that is always triggered imidiately.</p> Example <pre><code>    from aioclock import AioClock,\n\n    app = AioClock()\n\n    # instead of this:\n    async def my_task():\n        while True:\n            try:\n                await asyncio.sleep(3)\n                1/0\n            excpet DivisionByZero:\n                pass\n\n    # use this:\n    @app.task(trigger=Forever())\n    async def my_task():\n        await asyncio.sleep(3)\n        1/0\n</code></pre> <p>Attributes:</p> Name Type Description <code>type_</code> <code>Literal[FOREVER]</code> <p>Type of the trigger. It is a string, which is used to identify the trigger's name. You can change the type by using <code>Generic</code> type when inheriting from <code>BaseTrigger</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.LoopController","title":"LoopController","text":"<p>             Bases: <code>BaseTrigger</code>, <code>ABC</code>, <code>Generic[TriggerTypeT]</code></p> <p>Base class for all triggers that have loop control.</p> <p>Attributes:</p> Name Type Description <code>type_</code> <code>TriggerTypeT</code> <p>Type of the trigger. It is a string, which is used to identify the trigger's name. You can change the type by using <code>Generic</code> type when inheriting from <code>LoopController</code>.</p> <code>max_loop_count</code> <code>Union[PositiveInt, None]</code> <p>The maximum number of times the event should be triggered. If set to 3, then 4th time the event will not be triggered. If set to None, it will keep running forever. This is available for all triggers that inherit from <code>LoopController</code>.</p> <code>_current_loop_count</code> <code>int</code> <p>Current loop count, which is used to keep track of the number of times the event has been triggered. Private attribute, should not be accessed directly. This is available for all triggers that inherit from <code>LoopController</code>.</p>"},{"location":"api/triggers/#aioclock.triggers.Once","title":"Once","text":"<p>             Bases: <code>LoopController[Literal[ONCE]]</code></p> <p>A trigger that is triggered only once. It is used to trigger the event only once, and then stop.</p> Example <pre><code>from aioclock import AioClock, Once\napp = AioClock()\n\napp.task(trigger=Once())\nasync def task():\n    print(\"Hello World!\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>max_loop_count</code> <code>Literal[1]</code> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.OnStartUp","title":"OnStartUp","text":"<p>             Bases: <code>LoopController[Literal[ON_START_UP]]</code></p> <p>Just like Once, but it triggers the event only once, when the application starts up.</p> Example <pre><code>from aioclock import AioClock, OnStartUp\napp = AioClock()\n\napp.task(trigger=OnStartUp())\nasync def task():\n    print(\"Hello World!\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>max_loop_count</code> <code>Literal[1]</code> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.OnShutDown","title":"OnShutDown","text":"<p>             Bases: <code>LoopController[Literal[ON_SHUT_DOWN]]</code></p> <p>Just like Once, but it triggers the event only once, when the application shuts down.</p> Example <pre><code>from aioclock import AioClock, OnShutDown\napp = AioClock()\n\napp.task(trigger=OnShutDown())\nasync def task():\n    print(\"Hello World!\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>max_loop_count</code> <code>Literal[1]</code> <p>The maximum number of times the event should be triggered. Should be always 1 for this trigger.</p>"},{"location":"api/triggers/#aioclock.triggers.Every","title":"Every","text":"<p>             Bases: <code>LoopController[Literal[EVERY]]</code></p> <p>A trigger that is triggered every x time units.</p> Example <pre><code>from aioclock import AioClock, Every\napp = AioClock()\n\napp.task(trigger=Every(seconds=3))\nasync def task():\n    print(\"Hello World!\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>first_run_strategy</code> <code>Literal['immediate', 'wait']</code> <p>Strategy to use for the first run. If <code>immediate</code>, then the event will be triggered immediately,     and then wait for the time to trigger the event again. If <code>wait</code>, then the event will wait for the time to trigger the event for the first time.</p> <code>seconds</code> <code>Union[PositiveNumber, None]</code> <p>Seconds to wait before triggering the event.</p> <code>minutes</code> <code>Union[PositiveNumber, None]</code> <p>Minutes to wait before triggering the event.</p> <code>hours</code> <code>Union[PositiveNumber, None]</code> <p>Hours to wait before triggering the event.</p> <code>days</code> <code>Union[PositiveNumber, None]</code> <p>Days to wait before triggering the event.</p> <code>weeks</code> <code>Union[PositiveNumber, None]</code> <p>Weeks to wait before triggering the event.</p>"},{"location":"api/triggers/#aioclock.triggers.At","title":"At","text":"<p>             Bases: <code>LoopController[Literal[AT]]</code></p> <p>A trigger that is triggered at a specific time.</p> Example <pre><code>from aioclock import AioClock, At\n\napp = AioClock()\n\n@app.task(trigger=At(hour=12, minute=30, tz=\"Asia/Kolkata\"))\nasync def task():\n    print(\"Hello World!\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>second</code> <code>Annotated[int, Interval(ge=0, le=59)]</code> <p>Second to trigger the event.</p> <code>minute</code> <code>Annotated[int, Interval(ge=0, le=59)]</code> <p>Minute to trigger the event.</p> <code>hour</code> <code>Annotated[int, Interval(ge=0, le=24)]</code> <p>Hour to trigger the event.</p> <code>at</code> <code>Literal['every monday', 'every tuesday', 'every wednesday', 'every thursday', 'every friday', 'every saturday', 'every sunday', 'every day']</code> <p>Day of week to trigger the event. You would get the in-line typing support when using the trigger.</p> <code>tz</code> <code>str</code> <p>Timezone to use for the event.</p>"},{"location":"examples/brokers/","title":"Using with Message Brokers","text":"<p>You can basically run any tasks on aioclock, it could be your redis broker or other kind of brokers listening to a queue. The benefit of doing so, is that you don't need to worry about dependency injection, shutdown or startup event.</p> <p>AioClock offer you a unique easy way to spin up new services, without any overhead or perfomance issue!</p> <pre><code>from aioclock import AioClock, Forever, OnShutDown\nfrom functools import lru_cache\nfrom your_module import BrokerType\n\napp = AioClock()\n\n# your singleton redis instance\n@lru_cache\ndef get_redis() -&gt; BrokerType:\n    ...\n\n\n@app.task(trigger=Forever())\nasync def read_message_queue(redis: BrokerType = Depends(get_redis)):\n    async for message in redis.listen(\"...\"):\n        ...\n\n\n@app.task(trigger=OnShutDown())\nasync def shutdown_event(redis: BrokerType = Depends(get_redis)):\n    await redis.disconnect()\n</code></pre> <p>One other way to do this, is to implement a trigger that automatically execute the function. But to do so, I basically need to wrap redis in my own library, and that's not good for some reasons:</p> <ol> <li>Complexity of framework increases.</li> <li>Is not realy flexible, because native library and client are always way more flexible. I end up writing something like <code>Celery</code>.</li> <li>The architecture I choose to handle interactions with broker may not satisfy your requirement.</li> </ol> <p>This repository is an example how you can write a message queue in aioclock.</p>"},{"location":"examples/fastapi/","title":"Using with FastAPI","text":"<p>To run AioClock with FastAPI, you can run it in the background with FastAPI lifespan, next to your asgi.</p> <pre><code>from aioclock import AioClock\nfrom fastapi import FastAPI\nimport asyncio\nfrom contextlib import asynccontextmanager\n\nclock_app = AioClock()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    task = asyncio.create_task(clock_app.serve())\n    yield\n\n    try:\n        task.cancel()\n        await task\n    except asyncio.CancelledError:\n        ...\n\napp = FastAPI(lifespan=lifespan)\n</code></pre> <p>This setup is not recommended at all</p> <p>Running AioClock with FastAPI is not a good practice in General, because: FastAPI is a framework to write stateless API, but aioclock is still stateful component in your architecture. In simpler terms, it means if you have 5 instances of aioclock running, they produce 5x tasks than you intended. So you cannot easily scale up horizontally by adding more aioclock power!</p> <p>Even in this case, if you serve FastAPI with multiple processes, you end up having one aioclock per process!</p> <p>What I suggest doing is to spin one new service, that is responsible for processing the periodic tasks. Try to avoid periodic tasks in general, but sometimes it's not easy to do so.</p>"}]}